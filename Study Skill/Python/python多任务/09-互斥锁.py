import threading


# 实例化互斥锁对象
mutex = threading.Lock()

# 上锁
mutex.acquire()

print("测试")
"""
在上锁和解锁之间的代码不可被影响，要么一次性执行完毕，要么不执行
"""
# # 再次上锁
# mutex.acquire()
"""
就是一个线程执行它锁住的代码，必须一次性执行完毕，然后呢又调用了一次acquire()，但是呢这个线程已经锁住了
如果要再次锁的话，需要解锁，但是呢解锁的代码在后面，然后呢也锁不上，这里就一直等待这个线程解锁然后又解锁不了

但是如果想锁多次，那么可以实例化RLock，这个实例化可以重入，意思就是同一个线程可以多次获取锁，但是必须解锁对应的锁

tip:
    with 语句可以自动实现加锁和解锁
"""

# 解锁
mutex.release()
# # 试图再次解锁-----不可！
# mutex.release()
